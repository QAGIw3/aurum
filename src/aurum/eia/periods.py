"""Parse EIA period tokens into canonical UTC intervals."""
from __future__ import annotations

import re
from dataclasses import dataclass
from datetime import datetime, timedelta, timezone
from typing import Callable

from dateutil import parser as dateutil_parser


@dataclass(frozen=True)
class ParsedPeriod:
    """Normalized representation of an EIA period token."""

    period: str
    frequency: str
    start: datetime
    end: datetime


_PERIOD_TOKEN_QUARTER = re.compile(r"^(?P<year>\d{4})[\- ]?(?:Q|q)?(?P<quarter>[1-4])$")
_PERIOD_TOKEN_MONTH = re.compile(r"^(?P<year>\d{4})[-/]?(?P<month>\d{1,2})$")


class PeriodParseError(ValueError):
    """Raised when a period token cannot be normalized."""


def _ensure_utc(moment: datetime) -> datetime:
    if moment.tzinfo is None:
        return moment.replace(tzinfo=timezone.utc)
    return moment.astimezone(timezone.utc)


def _add_months(dt: datetime, months: int) -> datetime:
    month = dt.month - 1 + months
    year = dt.year + month // 12
    month = month % 12 + 1
    day = min(dt.day, _days_in_month(year, month))
    return dt.replace(year=year, month=month, day=day)


def _days_in_month(year: int, month: int) -> int:
    if month == 2:
        leap = year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)
        return 29 if leap else 28
    if month in {4, 6, 9, 11}:
        return 30
    return 31


def _parse_annual(token: str) -> tuple[datetime, datetime]:
    year = int(token)
    start = datetime(year, 1, 1, tzinfo=timezone.utc)
    end = datetime(year + 1, 1, 1, tzinfo=timezone.utc)
    return start, end


def _parse_quarterly(token: str) -> tuple[datetime, datetime]:
    match = _PERIOD_TOKEN_QUARTER.match(token)
    if not match:
        raise PeriodParseError(f"Invalid quarterly token: {token}")
    year = int(match.group("year"))
    quarter = int(match.group("quarter"))
    month = (quarter - 1) * 3 + 1
    start = datetime(year, month, 1, tzinfo=timezone.utc)
    end = _add_months(start, 3)
    return start, end


def _parse_monthly(token: str) -> tuple[datetime, datetime]:
    match = _PERIOD_TOKEN_MONTH.match(token)
    if not match:
        raise PeriodParseError(f"Invalid monthly token: {token}")
    year = int(match.group("year"))
    month = int(match.group("month"))
    if month < 1 or month > 12:
        raise PeriodParseError(f"Invalid month value in token: {token}")
    start = datetime(year, month, 1, tzinfo=timezone.utc)
    end = _add_months(start, 1)
    return start, end


def _parse_weekly(token: str) -> tuple[datetime, datetime]:
    try:
        day = datetime.strptime(token, "%Y-%m-%d")
    except ValueError as exc:
        raise PeriodParseError(f"Invalid weekly token: {token}") from exc
    start = day.replace(tzinfo=timezone.utc)
    end = start + timedelta(days=7)
    return start, end


def _parse_daily(token: str) -> tuple[datetime, datetime]:
    try:
        day = datetime.strptime(token, "%Y-%m-%d")
    except ValueError as exc:
        raise PeriodParseError(f"Invalid daily token: {token}") from exc
    start = day.replace(tzinfo=timezone.utc)
    end = start + timedelta(days=1)
    return start, end


def _parse_hourly(token: str) -> tuple[datetime, datetime]:
    try:
        instant = dateutil_parser.isoparse(token)
    except (ValueError, TypeError) as exc:
        raise PeriodParseError(f"Invalid hourly token: {token}") from exc
    start = _ensure_utc(instant)
    end = start + timedelta(hours=1)
    return start, end


_PARSERS: dict[str, Callable[[str], tuple[datetime, datetime]]] = {
    "ANNUAL": _parse_annual,
    "QUARTERLY": _parse_quarterly,
    "MONTHLY": _parse_monthly,
    "WEEKLY": _parse_weekly,
    "DAILY": _parse_daily,
    "HOURLY": _parse_hourly,
}


def parse_period_token(token: str, frequency: str) -> ParsedPeriod:
    if not token:
        raise PeriodParseError("Empty period token")
    if not frequency:
        raise PeriodParseError("Frequency is required")
    normalized_frequency = frequency.strip().upper()
    parser = _PARSERS.get(normalized_frequency)
    if not parser:
        raise PeriodParseError(f"Unsupported frequency: {frequency}")
    start, end = parser(token.strip())
    return ParsedPeriod(period=token, frequency=normalized_frequency, start=start, end=end)


def build_sql_period_expressions(
    frequency: str,
    *,
    period_column: str = "period",
) -> tuple[str, str]:
    """Return SQL expressions that derive start/end microsecond timestamps.

    The expressions are generated by the Python parser library so the canonical
    parsing rules live in a single place. Each expression returns a BIGINT
    representing microseconds from the Unix epoch.
    """

    if not frequency:
        raise PeriodParseError("Frequency is required for SQL generation")

    col = period_column
    upper = frequency.strip().upper()

    if upper == "ANNUAL":
        start = (
            f"CAST(UNIX_TIMESTAMP(CONCAT({col}, '-01-01'), 'yyyy-MM-dd') * 1000000 AS BIGINT)"
        )
        end = (
            "CAST(UNIX_TIMESTAMP(add_months(to_timestamp(CONCAT("
            + col
            + " , '-01-01'), 'yyyy-MM-dd'), 12)) * 1000000 AS BIGINT)"
        )
        return start, end

    if upper == "QUARTERLY":
        quarter_month = (
            "CASE"
            " WHEN UPPER(" + col + ") LIKE '%Q1' THEN '01'"
            " WHEN UPPER(" + col + ") LIKE '%Q2' THEN '04'"
            " WHEN UPPER(" + col + ") LIKE '%Q3' THEN '07'"
            " WHEN UPPER(" + col + ") LIKE '%Q4' THEN '10'"
            " ELSE '01'"
            " END"
        )
        start = (
            "CAST(UNIX_TIMESTAMP(to_timestamp(CONCAT(SUBSTR(" + col + ", 1, 4), '-' , "
            + quarter_month
            + ", '-01'), 'yyyy-MM-dd')) * 1000000 AS BIGINT)"
        )
        end = (
            "CAST(UNIX_TIMESTAMP(add_months(to_timestamp(CONCAT(SUBSTR(" + col + ", 1, 4), '-' , "
            + quarter_month
            + ", '-01'), 'yyyy-MM-dd'), 3)) * 1000000 AS BIGINT)"
        )
        return start, end

    if upper == "MONTHLY":
        month_token = (
            "CASE"
            " WHEN LENGTH(" + col + ") = 6 THEN CONCAT(SUBSTR(" + col + ", 1, 4), '-', SUBSTR(" + col + ", 5, 2))"
            " WHEN LENGTH(" + col + ") = 7 AND INSTR(" + col + ", '-') = 5 THEN " + col + ""
            " WHEN LENGTH(" + col + ") = 7 THEN CONCAT(SUBSTR(" + col + ", 1, 4), '-', SUBSTR(" + col + ", 5, 2))"
            " ELSE " + col + ""
            " END"
        )
        start = (
            "CAST(UNIX_TIMESTAMP(to_timestamp(CONCAT("
            + month_token
            + ", '-01'), 'yyyy-MM-dd')) * 1000000 AS BIGINT)"
        )
        end = (
            "CAST(UNIX_TIMESTAMP(add_months(to_timestamp(CONCAT("
            + month_token
            + ", '-01'), 'yyyy-MM-dd'), 1)) * 1000000 AS BIGINT)"
        )
        return start, end

    if upper == "WEEKLY":
        start = (
            "CAST(UNIX_TIMESTAMP(to_timestamp(" + col + ", 'yyyy-MM-dd')) * 1000000 AS BIGINT)"
        )
        end = (
            "CAST(UNIX_TIMESTAMP(to_timestamp(" + col + ", 'yyyy-MM-dd') + INTERVAL 7 DAYS) * 1000000 AS BIGINT)"
        )
        return start, end

    if upper == "DAILY":
        start = (
            "CAST(UNIX_TIMESTAMP(to_timestamp(" + col + ", 'yyyy-MM-dd')) * 1000000 AS BIGINT)"
        )
        end = (
            "CAST(UNIX_TIMESTAMP(to_timestamp(" + col + ", 'yyyy-MM-dd') + INTERVAL 1 DAY) * 1000000 AS BIGINT)"
        )
        return start, end

    if upper == "HOURLY":
        base_ts = (
            "COALESCE(" \
            "CAST(UNIX_TIMESTAMP(to_timestamp(" + col + ", 'yyyy-MM-dd''T''HH:mm:ssXXX')) * 1000000 AS BIGINT)," \
            "CAST(UNIX_TIMESTAMP(to_timestamp(SUBSTR(" + col + ", 1, 19), 'yyyy-MM-dd''T''HH:mm:ss')) * 1000000 AS BIGINT))"
        )
        start = base_ts
        end = f"({base_ts} + 3600 * 1000000)"
        return start, end

    raise PeriodParseError(f"Unsupported frequency for SQL generation: {frequency}")


__all__ = [
    "ParsedPeriod",
    "PeriodParseError",
    "parse_period_token",
    "build_sql_period_expressions",
]
